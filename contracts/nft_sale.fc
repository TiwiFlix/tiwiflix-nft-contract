#include "imports/stdlib.fc";
#include "imports/op-codes.fc";

;;
;;  TON Direct Sale Smart Contract
;;

int min_tons_for_storage() asm "10000000 PUSHINT"; ;; 0.01 TON

;; Storage
;; is_complete: uint1
;; created_at: uint32
;; marketplace_address: MsgAddress
;; nft_address: MsgAddress
;; nft_owner_address: MsgAddress
;; full_price: Coins
;; marketplace_fee_address: MsgAddress
;; marketplace_fee: Coins
;; royalty_address: MsgAddress
;; royalty_amount: Coins

(int, int, slice, slice, slice, int, slice, int, slice, int) load_data() {
    slice ds = get_data().begin_parse();
    var (is_complete, created_at, marketplace_address, nft_address, nft_owner_address, full_price) = 
        (ds~load_uint(1), ds~load_uint(32), ds~load_msg_addr(), ds~load_msg_addr(), ds~load_msg_addr(), ds~load_coins());
    
    slice fees_slice = ds~load_ref().begin_parse();
    var (marketplace_fee_address, marketplace_fee, royalty_address, royalty_amount) = 
        (fees_slice~load_msg_addr(), fees_slice~load_coins(), fees_slice~load_msg_addr(), fees_slice~load_coins());
        
    return (is_complete, created_at, marketplace_address, nft_address, nft_owner_address, full_price, marketplace_fee_address, marketplace_fee, royalty_address, royalty_amount);
}

() save_data(int is_complete, int created_at, slice marketplace_address, slice nft_address, slice nft_owner_address, int full_price, slice marketplace_fee_address, int marketplace_fee, slice royalty_address, int royalty_amount) impure {
    set_data(begin_cell()
        .store_uint(is_complete, 1)
        .store_uint(created_at, 32)
        .store_slice(marketplace_address)
        .store_slice(nft_address)
        .store_slice(nft_owner_address)
        .store_coins(full_price)
        .store_ref(
            begin_cell()
                .store_slice(marketplace_fee_address)
                .store_coins(marketplace_fee)
                .store_slice(royalty_address)
                .store_coins(royalty_amount)
                .end_cell()
        )
        .end_cell());
}

() send_money(slice address, int amount) impure inline {
    var msg = begin_cell()
        .store_uint(0x10, 6) ;; nobounce
        .store_slice(address)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();
    send_raw_message(msg, 1);
}

() transfer_nft(slice nft_address, slice new_owner, slice response_addr) impure inline {
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(nft_address)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x5fcc3d14, 32) ;; op::transfer
        .store_uint(0, 64) ;; query_id
        .store_slice(new_owner)
        .store_slice(response_addr)
        .store_int(0, 1) ;; custom_payload
        .store_coins(0) ;; forward_amount
        .store_int(0, 1) ;; forward_payload
        .end_cell();
    send_raw_message(msg, 128); ;; Carry all remaining gas
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { return (); }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { return (); }
    slice sender = cs~load_msg_addr();

    var (is_complete, created_at, marketplace_address, nft_address, nft_owner_address, full_price, marketplace_fee_address, marketplace_fee, royalty_address, royalty_amount) = load_data();

    if (is_complete == 1) {
        return ();
    }

    int op = in_msg_body~load_uint(32);
    
    ;; Cancel Sale
    if (op == 1) { 
        throw_unless(401, equal_slices(sender, nft_owner_address));
        save_data(1, created_at, marketplace_address, nft_address, nft_owner_address, full_price, marketplace_fee_address, marketplace_fee, royalty_address, royalty_amount);
        transfer_nft(nft_address, nft_owner_address, nft_owner_address);
        return ();
    }

    ;; NFT Ownership Assigned (Notification)
    if (op == 0x05138d91) {
        ;; The NFT has been transferred to us.
        ;; We could verify sender == nft_address, but for now we just accept it.
        return ();
    }

    ;; Buy (or just receive money)
    if (op == 0) {
        ;; Simple transfer
    }
    
    if (msg_value >= full_price) {
        ;; BUY SUCCESS
        
        ;; 1. Send Marketplace Fee
        if (marketplace_fee > 0) {
            send_money(marketplace_fee_address, marketplace_fee);
        }
        
        ;; 2. Send Royalty
        if (royalty_amount > 0) {
            send_money(royalty_address, royalty_amount);
        }
        
        ;; 3. Send Remainder to Seller
        int remainder = full_price - marketplace_fee - royalty_amount;
        if (remainder > 0) {
            send_money(nft_owner_address, remainder);
        }
        
        ;; 4. Transfer NFT to Buyer
        save_data(1, created_at, marketplace_address, nft_address, nft_owner_address, full_price, marketplace_fee_address, marketplace_fee, royalty_address, royalty_amount);
        transfer_nft(nft_address, sender, sender); 
        ;; transfer_nft uses mode 128 (carry remaining gas), so excess msg_value automatically goes to `response_addr` (which is `sender` / Buyer).
        ;; So explicit refund logic is NOT needed if we use mode 128 for the LAST message (NFT transfer).
        
        return ();
    }
    
    throw(0xffff);
}

;; Get Method compatible with GetGems
(int, int, int, slice, slice, slice, int, slice, int, slice, int) get_sale_data() method_id {
    var (is_complete, created_at, marketplace_address, nft_address, nft_owner_address, full_price, marketplace_fee_address, marketplace_fee, royalty_address, royalty_amount) = load_data();
    return (0x46495850, is_complete, created_at, marketplace_address, nft_address, nft_owner_address, full_price, marketplace_fee_address, marketplace_fee, royalty_address, royalty_amount);
}

